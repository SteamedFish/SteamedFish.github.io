<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on SteamedFish&#39;s BLOG</title>
        <link>https://blog.steamedfish.org/posts/</link>
        <description>Recent content in Posts on SteamedFish&#39;s BLOG</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>SteamedFish&#39;s BLOG</copyright>
        <lastBuildDate>Thu, 06 Jun 2019 16:45:14 +0800</lastBuildDate>
        <atom:link href="https://blog.steamedfish.org/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>为什么执行 mv 之后，文件的 ctime 会发生变化？</title>
            <link>https://blog.steamedfish.org/posts/2019/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C-mv-%E4%B9%8B%E5%90%8E%E6%96%87%E4%BB%B6%E7%9A%84-ctime-%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</link>
            <pubDate>Thu, 06 Jun 2019 16:45:14 +0800</pubDate>
            
            <guid>https://blog.steamedfish.org/posts/2019/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C-mv-%E4%B9%8B%E5%90%8E%E6%96%87%E4%BB%B6%E7%9A%84-ctime-%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</guid>
            <description>问题 我们都知道文件包含以下这几个时间相关的属性： Access: 2019-04-26 14:56:17.086659763 +0800 Modify: 2019-04-26 14:54:09.626659782 +0800 Change: 2019-06-04 17:10:13.473326466 +0800 Birth: 2019-04-26 14:53:42.413326457 +0800 其中： Access 为最后一次读取文件内容的时间 Modify 为最后一次改变文件内容</description>
            <content type="html"><![CDATA[<h1 id="问题">问题</h1>

<p>我们都知道文件包含以下这几个时间相关的属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-language" data-lang="language">Access: 2019-04-26 14:56:17.086659763 +0800
Modify: 2019-04-26 14:54:09.626659782 +0800
Change: 2019-06-04 17:10:13.473326466 +0800
 Birth: 2019-04-26 14:53:42.413326457 +0800</code></pre></div>
<p>其中：</p>

<ul>
<li>Access 为最后一次读取文件内容的时间</li>
<li>Modify 为最后一次改变文件内容的时间</li>
<li>Change 为最后一次改变文件属性的时间</li>
<li>Birth 为文件创建的时间</li>
</ul>

<p>一个有趣的现象是，在对文件进行重命名操作的时候（ <code>mv a b</code> ），理论上，文件内容不会
被读取，该文件的内容和任何属性也不会被改变，但是它的 ctime，也就是 Change time，
却发生了变化。这是为什么呢？</p>

<h1 id="分析">分析</h1>

<p>让我们看一下 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html" title="POSIX 的规定">POSIX 的规定</a>，结果发现，POSIX 对此是未定义的：</p>

<p>Some implementations mark for update the last file status change timestamp of
renamed files and some do not. Applications which make use of the last file
status change timestamp may behave differently with respect to renamed files
unless they are designed to allow for either behavior.</p>

<p>于是我们只能去读源码了。</p>

<h1 id="源码分析">源码分析</h1>

<h2 id="ext4-的实现">ext4 的实现</h2>

<p>在 ext4 的 <a href="https://github.com/torvalds/linux/blob/master/fs/ext4/namei.c#L3727" title="源码">源码</a> 中，是直接强行修改了 ctime 的，还说大家都这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * Like most other Unix systems, set the ctime for inodes on a
</span><span class="cm"> * rename.
</span><span class="cm"> */</span>
<span class="n">old</span><span class="p">.</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">current_time</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">inode</span><span class="p">);</span></code></pre></div>
<h2 id="reiserfs-的实现">reiserfs 的实现</h2>

<p>在 reiserfs 的 <a href="https://github.com/torvalds/linux/blob/master/fs/reiserfs/namei.c#L1574" title="源码">源码</a> 中，也是强行修改了 ctime，还特意说明之前不修改是个 bug：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm">  * thanks to Alex Adriaanse &lt;alex_a@caltech.edu&gt; for patch
</span><span class="cm">  * which adds ctime update of renamed object
</span><span class="cm">  */</span>
<span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ctime</span><span class="p">;</span></code></pre></div>
<h2 id="xfs-的实现">XFS 的实现</h2>

<p>感谢 XFS，在实现中给出了非常详细的解释，让我们终于明白为什么需要强行修改 ctime
了。我们看一下 <a href="https://github.com/torvalds/linux/blob/master/fs/xfs/xfs_inode.c#L3385" title="源码">源码</a>：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * We always want to hit the ctime on the source inode.
</span><span class="cm"> *
</span><span class="cm"> * This isn&#39;t strictly required by the standards since the source
</span><span class="cm"> * inode isn&#39;t really being changed, but old unix file systems did
</span><span class="cm"> * it and some incremental backup programs won&#39;t work without it.
</span><span class="cm"> */</span>
<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span></code></pre></div>
<h1 id="结论">结论</h1>

<p>mv 文件的时候，确实不会修改文件的属性信息，理论上 ctime 是不会变化的。但是这样会
导致很多依赖于文件修改时间的程序（例如一些增量备份程序）出现 BUG，因此绝大多数文
件系统在处理 mv 操作的时候都强行修改了 ctime 时间。</p>
]]></content>
        </item>
        
        <item>
            <title>systemd-journal 占用内存的问题</title>
            <link>https://blog.steamedfish.org/posts/2019/06/systemd-journal-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</link>
            <pubDate>Tue, 04 Jun 2019 17:00:08 +0800</pubDate>
            
            <guid>https://blog.steamedfish.org/posts/2019/06/systemd-journal-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
            <description>systemd-journal 占用内存的问题 最近发现部分 Debian 机器的 systemd-journal 占用了非常多内存。这和 Debian 对其的 错误配置有关系（查了一下其他发行版，有和 Debian 一样的配置的也有和 Debian 不一样 的配</description>
            <content type="html"><![CDATA[

<h1 id="systemd-journal-占用内存的问题">systemd-journal 占用内存的问题</h1>

<p>最近发现部分 Debian 机器的 systemd-journal 占用了非常多内存。这和 Debian 对其的
错误配置有关系（查了一下其他发行版，有和 Debian 一样的配置的也有和 Debian 不一样
的配置的，说明这个配置有争议）。</p>

<h2 id="systemd-journal-简介">systemd-journal 简介</h2>

<p>systemd-journal 是 systemd 引入的系统日志记录工具。其优势是：</p>

<ul>
<li>使用二进制保存日志，有压缩，体积小</li>
<li>可以记录启动早期，磁盘还没挂载之前，rsyslog 还没启动时候的系统日志</li>
<li>有索引，可以快速搜索</li>
<li>索引包含了多种类型，可以方便使用多种维度，以及他们的组合，进行搜索，包含但不限
于：

<ul>
<li>时间</li>
<li>PID</li>
<li>程序可执行文件路径</li>
<li>service 名称</li>
<li>用户</li>
<li>内核</li>
<li>错误级别</li>
</ul></li>
<li>显示的时候，可以针对不同等级做高亮，可以转换日志时间戳</li>
<li>可以针对日志设置用户访问权限控制</li>
<li>会对日志做校验，用户无法修改任何日志，日志也不能伪造用户、processid 等敏感信息</li>
<li>可以设置 rotate 和最大体积等各种限制，也可以比较方便地手工清理指定时间之前的日
志</li>
<li>支持 syslog 的所有日志级别</li>
<li>支持复制日志并转发到 rsyslog</li>
</ul>

<p>由于可以方便地过滤某个时间段的所有程序的日志，所以 journal 特别适合 debug 一些多
种环境下，会有多个日志源的复杂问题，可以按时间顺序将所有日志源共同打印出来，从而
清晰地观察到各种应用程序之间的交互顺序。</p>

<p>其缺点是：</p>

<ul>
<li>不支持 rsyslog 的复制日志和转发过滤等功能</li>
</ul>

<p>由于游戏需要 rsyslog 的转发过滤，因此我们一般都会打开 rsyslog，因此在 Debian 中，
日志会首先到达 systemd-journal，并且被保存为 journal 文件，同时再转一个副本给
rsyslog，由 rsyslog 控制写到 <code>/var/log/</code> 目录下，或者游戏项目自行设置的其他路径
下。</p>

<h2 id="systemd-journal-的配置">systemd-journal 的配置</h2>

<p>在 <code>/etc/systemd/journald.conf</code> 下面。支持的配置项还是比较多的。具体可以参考
<code>man 5 journald.conf</code></p>

<h2 id="systemd-journal-的使用">systemd-journal 的使用</h2>

<p>使用 <code>journalctl</code> 命令。具体参数可以 <code>man 1 journalctl</code> 查看。</p>

<h2 id="systemd-journal-的坑">systemd-journal 的坑</h2>

<p>默认的配置文件，配置了 <code>Storage=auto</code>。含义为：</p>

<ul>
<li>如果设置为 volatile，journal 将会保存在内存中，使用位于内存盘的
<code>/run/log/journal</code> 目录（会自动创建）</li>
<li>如果设置为 persistent，journal 将会保存在磁盘中，使用 <code>/var/log/journal</code> 目录
（会自动创建），如果自动创建失败，以及针对启动早期磁盘尚未挂载成功的部分日志，
仍然记录在内存盘。</li>
<li>如果设置为 auto，那么，如果 <code>/var/log/journal</code> 目录存在，则使用该目录记录到磁
盘，如果目录不存在（不会自动创建），则使用内存盘。</li>
<li>如果设置为 none，完全不记录任何日志（但是仍然可以转发给 rsyslog）</li>
<li>默认是 auto</li>
</ul>

<p>而 Debian 默认并不会创建 <code>/var/log/journal</code> 目录（查了一下其他发行版，有创建的有
不创建的，看来不同发行版是有分歧的）。因此会导致默认配置情况下，journal 默认会将
日志全部保存在内存盘中。</p>

<p>在我们长期不关机的情况下，<code>/run/log/journal</code> 目录可能会变得非常大，从而导致占据
较多内存。</p>

<p>systemd 默认的配置，对总的存储空间做了上限。上限如下：</p>

<ul>
<li>如果使用的是磁盘，那么上限默认为磁盘空间的 10% 和 4G 中较小的那个（由
<code>SystemMaxUse</code> 控制）</li>
<li>如果使用的是内存，那么上限默认为内存空间的 15% 和 4G 中较小的那个（由
<code>RuntimeMaxUse</code> 控制）</li>
</ul>

<p>因此，极端情况下，journal 可能会消耗 4G 的内存。</p>

<h2 id="清理-journal-的内存">清理 journal 的内存</h2>

<ul>
<li>清除到只剩下最新的 100M 空间：<code>journalctl --vacuum-size=100M</code></li>
<li>清除到只剩下最近两小时：<code>journalctl --vacuum-time=2h</code></li>
<li>将内存盘中的数据刷到硬盘：<code>journalctl --flush</code></li>
<li>或者采用很黄很暴力的清除方法（不推荐）：<code>rm -rf /run/log/journal &amp;&amp; systemctl
restart systemd-journal</code></li>
</ul>

<h2 id="建议的解决办法">建议的解决办法：</h2>

<p>以下方法任选一种即可</p>

<ul>
<li>方法一：创建 <code>/var/log/journal</code> 目录，然后使用 <code>journalctl --flush</code> 将内存盘中
的数据刷到硬盘</li>
<li>方法二：修改 <code>/etc/systemd/journald.conf</code>，配置 <code>Storage=persistent</code>，然后重启
<code>systemd-journal</code> 并使用 <code>journalctl --flush</code> 将内存盘中的数据刷到硬盘</li>
<li>方法三：修改 <code>/etc/systemd/journald.conf</code>，配置 <code>Storage=none</code>，然后重启
<code>systemd-journal</code></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Emacs 在 .dir-locals.el 中执行 elisp 语句</title>
            <link>https://blog.steamedfish.org/posts/2019/05/emacs-%E5%9C%A8-.dir-locals.el-%E4%B8%AD%E6%89%A7%E8%A1%8C-elisp-%E8%AF%AD%E5%8F%A5/</link>
            <pubDate>Fri, 03 May 2019 22:53:09 +0800</pubDate>
            
            <guid>https://blog.steamedfish.org/posts/2019/05/emacs-%E5%9C%A8-.dir-locals.el-%E4%B8%AD%E6%89%A7%E8%A1%8C-elisp-%E8%AF%AD%E5%8F%A5/</guid>
            <description>在 .dir-locals.el 中可以控制目录级别的变量。这个文件不是一个 elisp 代码文件， 而是只能存放一个 Association List （联合列表，alist）的列表。 这个联合列表里面的每个 cons cell 的 car</description>
            <content type="html"><![CDATA[<p>在 <code>.dir-locals.el</code> 中可以控制目录级别的变量。这个文件不是一个 elisp 代码文件，
而是只能存放一个 Association List （联合列表，alist）的列表。</p>

<p>这个联合列表里面的每个 cons cell 的 car 是希望生效的模式，cdr 则又是一个 alist，
用于给变量赋值。</p>
<div class="highlight"><pre class="chroma"><code class="language-elisp" data-lang="elisp"><span class="p">(</span> <span class="c1">;; 一个大列表，里面是很多 alist</span>
 <span class="p">(</span><span class="nv">c-mode</span> <span class="o">.</span> <span class="p">(</span>  <span class="c1">;; 这个 alist 控制 c-mode 模式下的行为，其中 cdr 又是一个 alist</span>
            <span class="p">(</span><span class="nv">c-file-style</span> <span class="o">.</span> <span class="s">&#34;BSD&#34;</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">subdirs</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)</span>
           <span class="p">)</span>
 <span class="p">)</span>
 <span class="p">(</span><span class="no">nil</span> <span class="o">.</span> <span class="p">(</span>     <span class="c1">;; 这个 alist 对所有 mode 生效</span>
         <span class="p">(</span><span class="nv">indent-tabs-mode</span> <span class="o">.</span> <span class="no">t</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">tab-witdh</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">fill-column</span> <span class="o">.</span> <span class="mi">80</span><span class="p">)</span>
        <span class="p">)</span>
 <span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>那么问题来了，有时候我们希望能够不仅仅是赋值，而是执行 elisp 语句。这个时候我们
不需要赋值，需要的是语句的副作用。我们可以将其赋值给随便一个不需要的变量上，例如
叫 <code>eval</code> 。然后我们就可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-elisp" data-lang="elisp"><span class="p">((</span><span class="nv">c-mode</span> <span class="o">.</span> <span class="p">((</span><span class="nv">c-file-style</span> <span class="o">.</span> <span class="s">&#34;BSD&#34;</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">subdirs</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)))</span>
 <span class="p">(</span><span class="no">nil</span> <span class="o">.</span> <span class="p">((</span><span class="nv">indent-tabs-mode</span> <span class="o">.</span> <span class="no">t</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">tab-witdh</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">fill-column</span> <span class="o">.</span> <span class="mi">80</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">eval</span> <span class="o">.</span> <span class="p">(</span><span class="nb">progn</span>
                   <span class="p">(</span><span class="nv">flycheck-mode</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">xxxxxx</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">xxxxx</span><span class="p">))))))</span></code></pre></div>
<p>不过这样会导致 Emacs 在加载这个文件的时候，提示你加载了一个不安全的文件，并且让
你选择究竟是不加载，还是只允许一次，还是永久加载。如果选择永久加载，emacs 会记录
在 <code>custom.el</code> 中。</p>
]]></content>
        </item>
        
    </channel>
</rss>
